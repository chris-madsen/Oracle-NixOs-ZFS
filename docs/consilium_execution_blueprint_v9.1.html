<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>CONSILIUM EXECUTION BLUEPRINT v9.1</title>
  <style>
:root { --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
html { font-size: 12pt; }
body {
  font-family: "DejaVu Sans", Arial, sans-serif;
  line-height: 1.35;
  margin: 2.2cm 2.0cm;
  color: #111;
}
h1, h2, h3 { page-break-after: avoid; }
h1 { font-size: 20pt; margin-top: 0; }
h2 { font-size: 15pt; margin-top: 1.2em; }
h3 { font-size: 12.5pt; margin-top: 1.0em; }
hr { margin: 1.2em 0; }
code { font-family: var(--mono); font-size: 10.5pt; }
pre {
  font-family: var(--mono);
  font-size: 10pt;
  background: #f5f5f5;
  padding: 10px 12px;
  border: 1px solid #ddd;
  border-radius: 6px;
  overflow-x: auto;
}
blockquote {
  margin: 1em 0;
  padding: 0.6em 1em;
  border-left: 4px solid #bbb;
  background: #fafafa;
}
ul { margin-top: 0.3em; }
li { margin: 0.15em 0; }
table { border-collapse: collapse; }
th, td { border: 1px solid #ddd; padding: 6px 8px; }
</style>
</head>
<body>
<h1 id="consilium-execution-blueprint-v91-mvp">CONSILIUM EXECUTION BLUEPRINT v9.1 (MVP)</h1>
<p><strong>Target:</strong> Bittensor SN4 (Optimization / Dense QUBO)<br>
<strong>MVP Deadline:</strong> 28 Feb 2026<br>
<strong>Status:</strong> Engineering Specification (for implementation by 2-person team + AI)<br>
<strong>Confidentiality:</strong> Internal / do not distribute</p>
<hr>
<h2 id="0-executive-summary">0. Executive Summary</h2>
<p>This document is an implementation-focused translation of the “E8 + Topology + Quantum Scout” approach for Bittensor SN4.</p>
<p>Core idea (what to build):
- SN4 provides <strong>Dense QUBO</strong> instances <code>Q</code> under a strict time window.
- We extract fast <strong>topological signals</strong> from the task’s interaction structure (“holes/loops” → invariants like <code>β₁</code>) using an IBM/Qiskit <strong>Quantum Scout</strong> with strict timeouts and hard fallbacks.
- We construct a deterministic <strong>8D topological latent space</strong> and a projection matrix <code>W ∈ R^(8×N)</code> (“topological principal components”).
- We <strong>quantize</strong> the latent space against the <strong>E8 root system</strong> (240 roots = vertices of the Gosset polytope <code>4_21</code>) by snapping to the nearest E8 root vector.
- We <strong>lift</strong> the chosen E8 root direction back to an <code>N</code>-bit seed via <code>W⁺</code>, then run a short <strong>Lift &amp; Repair</strong> local search on the original <code>Q</code> to produce a valid submission.</p>
<p>MVP goal:
- Implement the full SN4 miner loop on <strong>testnet</strong> and demonstrate non-random positive incentive/score under strict latency constraints.</p>
<p>What is intentionally <em>not</em> explained here:
- Philosophical / “why E8” motivation. The spec focuses on I/O and determinism so an AI can implement it.</p>
<hr>
<h2 id="1-mvp-definition-scope">1. MVP Definition (Scope)</h2>
<h3 id="11-goal">1.1 Goal</h3>
<p>Achieve stable positive incentive/score on SN4 <strong>testnet</strong> by running a single miner instance continuously and submitting valid solutions.</p>
<h3 id="12-success-metrics-kpis">1.2 Success Metrics (KPIs)</h3>
<p>Define these numbers before Week 2 and keep them stable for the month:
- <strong>Median incentive/score ≥ <code>S_target</code></strong> over a continuous run of <code>T_eval</code> hours.
- <strong>p95 end-to-end latency ≤ <code>T_p95</code></strong> seconds (job received → tx submitted).
- <strong>Acceptance rate ≥ <code>R_accept</code></strong> (valid solutions / total attempts).
- <strong>Stability:</strong> <code>≥ 24h</code> continuous operation without crash.</p>
<p>Recommended initial targets (edit after first baseline run):
- <code>S_target = 0.001</code>
- <code>T_p95 = 45s</code>
- <code>R_accept = 80%</code>
- <code>T_eval = 24h</code></p>
<h3 id="13-non-goals-mvp">1.3 Non-Goals (MVP)</h3>
<ul>
<li>No GUI/front-end (CLI only).</li>
<li>No autoscaling / multi-node cluster management.</li>
<li>No mainnet risk in February (testnet only).</li>
<li>No “enterprise” observability; keep only minimal structured logs.</li>
</ul>
<h3 id="14-strategic-context-sniper-doctrine">1.4 Strategic Context (Sniper Doctrine)</h3>
<p>SN4 is treated as a <strong>time-windowed optimization market</strong>. The intended niche is:
- Dense / high-connectivity QUBOs where naive GPU heuristics struggle with state update costs.
- We ignore low-complexity instances and focus on tasks where the E8+topology pipeline gives asymmetric advantage.</p>
<hr>
<h2 id="2-the-interface-bittensor-sn4-contract-must-be-true">2. The Interface: Bittensor SN4 Contract (Must-Be-True)</h2>
<blockquote>
<p><strong>Important:</strong> v9.0 contained placeholder method names. For v9.1, treat SN4 I/O as <strong>contract-first</strong>: verify the real Synapse schema and submission call in the actual SN4 codebase before coding.</p>
</blockquote>
<h3 id="21-task-source">2.1 Task Source</h3>
<p>Miner receives tasks from SN4 validators via a Bittensor Synapse.</p>
<p>MVP deliverable:
- A single function that converts “Raw Synapse” → <code>(Q, meta)</code> where:
  - <code>Q</code>: dense matrix (<code>N×N</code>, <code>float32</code> preferred)
  - <code>meta</code>: includes at minimum <code>job_id</code>, <code>deadline_ts</code> or <code>timeout_s</code>, and any validator-provided scoring hints.</p>
<h3 id="22-task-data-model-schema-to-confirm">2.2 Task Data Model (Schema to confirm)</h3>
<p>Minimum fields we assume exist (or can be derived):
- <code>N</code> (int): number of variables (expected 2000–5000).
- <code>Q</code> (matrix): QUBO weights, typically in <code>[-1, 1]</code> (confirm).
- <code>domain</code> (enum): variables are either <code>{0,1}</code> or <code>{-1,1}</code> (confirm; implement conversion).
- <code>time_window_s</code> (float): hard deadline for response (confirm).</p>
<h3 id="23-solution-output-model">2.3 Solution Output Model</h3>
<p>Miner must output:
- <code>solution</code>: list/array of length <code>N</code> (binary/spins per subnet contract)
- optional <code>energy</code> (float) if accepted by protocol (confirm)
- signature / wallet metadata as required by Bittensor</p>
<h3 id="24-scoring-objective-mvp-assumption">2.4 Scoring Objective (MVP assumption)</h3>
<p>Assume validators reward:
- Lower energy <code>H(s)</code> is better
- Latency is a multiplier/penalty
- Invalid format or deadline miss → zero or negative</p>
<p>Define energy in a single canonical form internally, and convert at boundaries:
- Spin form: <code>s ∈ {-1, +1}^N</code>, <code>H(s) = sᵀ Q s</code>
- Binary form: <code>x ∈ {0, 1}^N</code>, <code>H(x) = xᵀ Q x</code></p>
<hr>
<h2 id="3-system-architecture-single-node-mvp">3. System Architecture (Single-Node MVP)</h2>
<h3 id="31-components">3.1 Components</h3>
<p>All components run on one host (laptop or server), with external calls to IBM/Qiskit and an optional solver service.</p>
<ul>
<li><strong>Ingest</strong>: Synapse → dense <code>Q</code>, <code>meta</code></li>
<li><strong>Quantum Scout</strong>: <code>(Q, meta)</code> → topological features <code>F</code> (with strict timeout + fallback)</li>
<li><strong>W Builder</strong>: <code>(Q, F)</code> → <code>W ∈ R^(8×N)</code> + cache key</li>
<li><strong>E8 Quantizer</strong>: <code>W, Q</code> → candidate roots <code>r_i</code> and/or best <code>r*</code></li>
<li><strong>Lift &amp; Repair</strong>: <code>(W, r*, Q)</code> → valid <code>N</code>-bit solution <code>s</code></li>
<li><strong>Submit</strong>: <code>s</code> → on-chain/testnet submission</li>
<li><strong>Logger</strong>: writes one JSON line per attempt (minimal observability)</li>
</ul>
<h3 id="32-degraded-modes-required-for-mvp">3.2 Degraded Modes (Required for MVP)</h3>
<p>The pipeline must always produce <em>some</em> output before deadline:
- <strong>Degraded-Q</strong>: Quantum Scout timed out → use cached <code>F_cache</code>
- <strong>Degraded-W</strong>: W build failed → use cached <code>W_cache</code> or deterministic default <code>W_default</code>
- <strong>Degraded-S</strong>: Repair cannot finish → return best-so-far seed solution</p>
<h3 id="33-hardware-roles-conceptual">3.3 Hardware Roles (Conceptual)</h3>
<ul>
<li><strong>Orchestrator (Local host):</strong> parsing, caching, building <code>W</code>, lift &amp; repair, submission.</li>
<li><strong>Scout (IBM Quantum / Qiskit Runtime):</strong> topological feature estimation under strict timeout.</li>
<li><strong>Hammer (optional external solver):</strong> if configured, solves/warms-starts candidate solutions within a time slice.</li>
</ul>
<hr>
<h2 id="4-the-sniper-loop-pipeline-deterministic-deadline-aware">4. The “Sniper Loop” Pipeline (Deterministic, Deadline-Aware)</h2>
<h3 id="41-hard-time-budget-initial">4.1 Hard Time Budget (initial)</h3>
<p>This is a starting point; tune after first testnet run.</p>
<ul>
<li>Step 1 Ingest: <code>0.5s</code></li>
<li>Step 2 Quantum Scout: <code>3.0s</code> (hard timeout)</li>
<li>Step 3 Build W: <code>5.0s</code></li>
<li>Step 4 E8 Quantize: <code>0.2s</code></li>
<li>Step 5 Lift &amp; Repair: <code>≤ (deadline - elapsed - submit_budget)</code> (target <code>2–20s</code>)</li>
<li>Step 6 Submit: <code>1.0s</code></li>
</ul>
<h3 id="42-filtering-sniper-scope">4.2 Filtering (Sniper Scope)</h3>
<p>We intentionally ignore tasks that do not match the dense/high-connectivity niche.</p>
<p>Define <strong>effective density</strong>:</p>
<pre><code>density_eps(Q, eps) = count(|Q_ij| &gt; eps) / (N*N)
</code></pre>
<p>Initial policy:
- If <code>N &lt; 2000</code>: DROP (optional; tune)
- If <code>density_eps(Q, eps=1e-3) &lt; 0.3</code>: DROP (tune)</p>
<h3 id="43-end-to-end-steps">4.3 End-to-End Steps</h3>
<p>1) <strong>Ingest</strong>
- Parse synapse, validate shapes/types, convert to internal canonical domain (spin or binary).
- Compute cheap stats: <code>N</code>, <code>density_eps</code>, min/max weight, symmetric check.</p>
<p>2) <strong>Quantum Scout (timeout hard)</strong>
- Compute topological features <code>F</code>:
  - must include at least <code>beta1_estimate</code> (even if approximate)
  - may include additional scalars: <code>components_estimate</code>, <code>spectral_near_zero</code>, etc.
- If timeout/error: load <code>F_cache</code> keyed by <code>(subnet_version, N_bucket, density_bucket)</code> or last-good.</p>
<p>3) <strong>Build W</strong>
- Build <code>W ∈ R^(8×N)</code> deterministically from <code>(Q, F)</code> (Section 6).
- Cache <code>W</code> for reuse across tasks (keyed by <code>N_bucket</code> + <code>beta1_bucket</code>).
- Precompute <code>W⁺</code> (pseudo-inverse) when W changes.</p>
<p>4) <strong>E8 Quantize</strong>
- Generate E8 roots (240 vectors in <code>R^8</code>) deterministically (Appendix A).
- Compute reduced matrix <code>Q8 = W Q Wᵀ</code> (8×8).
- Select root candidates <code>r</code> by minimizing reduced energy <code>E8(r) = rᵀ Q8 r</code>.
- Keep top <code>B</code> candidates (beam width; MVP start <code>B=8</code>).</p>
<p>5) <strong>Lift &amp; Repair (anytime)</strong>
For each candidate <code>r</code> in order:
- Lift: <code>s_seed = W⁺ r</code> (vector in <code>R^N</code>)
- Binarize/spinize: <code>s0 = binarize(s_seed)</code> (Section 6)
- Repair: run greedy local search on original <code>Q</code> under a strict time slice.
- Track best <code>(energy, solution)</code> and stop when remaining time is low.</p>
<p>6) <strong>Submit</strong>
- Submit best solution found.
- No artificial delays: submit as soon as ready.</p>
<hr>
<h2 id="5-mathematical-data-definitions">5. Mathematical &amp; Data Definitions</h2>
<h3 id="51-qubo-canonicalization">5.1 QUBO Canonicalization</h3>
<p>Pick one internal representation for MVP (recommended: <strong>spin</strong> <code>{-1,+1}</code>):
- If subnet uses <code>{0,1}</code>, convert to spin or implement both energy functions and repair deltas.</p>
<h3 id="52-e8-root-system-gosset-polytope-4_21">5.2 E8 Root System (Gosset Polytope <code>4_21</code>)</h3>
<p>We use the E8 root system as a fixed codebook of 240 vectors in <code>R^8</code>:
- All roots have equal norm (<code>||r||² = 2</code>)
- Two families:
  - Type A: permutations of <code>(±1, ±1, 0, 0, 0, 0, 0, 0)</code> → 112 roots
  - Type B: <code>(±1/2, …, ±1/2)</code> with an even number of minus signs → 128 roots</p>
<p>Engineering note:
- In MVP we do <strong>not</strong> need to implement Weyl-group actions explicitly; we only need the deterministic root codebook and snapping.</p>
<h3 id="53-projection-matrix-w">5.3 Projection Matrix <code>W</code></h3>
<p>Corrected definition (v9.1):
- <code>W ∈ R^(8×N)</code> maps <code>N</code>-dimensional states into an 8D latent space.
- <code>v = W s</code>, where <code>v ∈ R^8</code>, <code>s ∈ R^N</code> (a candidate state/seed).
- <code>W</code> is derived from topological structure (Section 6), not hand-tuned.</p>
<h3 id="54-snapping-quantization">5.4 Snapping / Quantization</h3>
<p>Given <code>v ∈ R^8</code>, snap to nearest E8 root:</p>
<pre><code>r* = argmin_{r in Roots_E8} ||v - r||_2
</code></pre>
<p>Since all roots share a constant norm, this is equivalent to maximizing dot product:</p>
<pre><code>r* = argmax_{r in Roots_E8} &lt;v, r&gt;
</code></pre>
<h3 id="55-pseudo-inverse">5.5 Pseudo-Inverse</h3>
<p>Given <code>W</code> has full row rank, compute:</p>
<pre><code>W⁺ = Wᵀ (W Wᵀ)^(-1)     # dimensions: (N×8)
</code></pre>
<p>Compute and cache <code>W⁺</code> whenever <code>W</code> changes.</p>
<hr>
<h2 id="6-e8-regularizer-engineering-specification">6. E8 Regularizer (Engineering Specification)</h2>
<h3 id="61-inputs-outputs">6.1 Inputs / Outputs</h3>
<p>Inputs:
- <code>Q</code>: dense <code>N×N</code> float32
- <code>F</code>: topological feature vector (at minimum <code>beta1_estimate</code>)</p>
<p>Outputs:
- <code>W</code>: <code>8×N</code> float32
- <code>W_plus</code>: <code>N×8</code> float32
- <code>Roots_E8</code>: list of 240 vectors in <code>R^8</code> (cached global constant)</p>
<h3 id="62-building-w-mvp-implementable">6.2 Building <code>W</code> (MVP-Implementable)</h3>
<p>We need 8 stable “topological principal components” for the task graph.</p>
<p>MVP method (deterministic, fast, reproducible):
1) Build a <strong>skeleton graph</strong> <code>G_skel</code> from <code>Q</code>:
   - For each node <code>i</code>, keep the <code>k</code> strongest interactions by <code>|Q_ij|</code>.
   - Symmetrize the edge set.
   - Set <code>k = clamp(k_min, k_max, f(beta1_estimate, N))</code>.
2) Build sparse adjacency <code>A</code> and graph Laplacian <code>L0 = D - A</code>.
3) Compute 8 eigenvectors associated with the smallest non-trivial eigenvalues of <code>L0</code>:
   - Stack them as rows of <code>W</code> (after normalization / orthonormalization).</p>
<p>Recommended MVP defaults:
- <code>k_min = 32</code>, <code>k_max = 256</code>
- <code>f(beta1, N) = round(16 + 2*min(beta1, 64))</code> (tune)</p>
<p>Notes:
- This matches the “topological components” intent and keeps runtime feasible at <code>N≈5000</code>.
- The Quantum Scout controls <code>beta1_estimate</code>, which controls skeletonization and stability of <code>W</code>.</p>
<h3 id="63-reduced-energy-selection-in-e8-space">6.3 Reduced Energy Selection in E8 Space</h3>
<p>Compute reduced matrix:</p>
<pre><code>Q8 = W Q Wᵀ     # 8×8
</code></pre>
<p>For each root <code>r</code>:</p>
<pre><code>E8(r) = rᵀ Q8 r
</code></pre>
<p>Select beam <code>B</code> roots with the lowest <code>E8(r)</code>.</p>
<h3 id="64-lift-repair">6.4 Lift &amp; Repair</h3>
<p>For each candidate root <code>r</code>:
1) Lift:</p>
<pre><code>s_seed = W⁺ r      # N-dimensional real vector
</code></pre>
<p>2) Binarize/spinize:
- If internal domain is spins: <code>s0_i = +1 if s_seed_i &gt;= 0 else -1</code>
- If internal domain is binary: <code>x0_i = 1 if s_seed_i &gt;= 0 else 0</code>
3) Repair (greedy local search on original <code>Q</code>):
- Run until time slice exhausted or no improving flips.
- Always maintain best-so-far solution.</p>
<p>Repair must be <strong>anytime</strong>:
- If time remains: continue improving
- If close to deadline: stop and return current best</p>
<p>Implementation detail for speed:
- Maintain <code>g = Q s</code> (or <code>Q x</code>) and update <code>g</code> after each flip so each flip is <code>O(N)</code>, not <code>O(N²)</code>.
(See Appendix B.)</p>
<h3 id="65-why-this-can-work-engineering-framing">6.5 Why this can work (engineering framing)</h3>
<p>The E8 root codebook provides a compact set of highly symmetric directions in 8D. The hypothesis is:
- The 8D embedding concentrates “energy landscape shape” into a small space.
- Snapping to E8 roots yields seeds that are closer to good minima than random initialization.</p>
<p>This is an empirical claim for MVP:
- We validate only by testnet score and golden-set energy distributions.</p>
<hr>
<h2 id="7-quantum-scout-engineering-specification">7. Quantum Scout (Engineering Specification)</h2>
<h3 id="71-purpose">7.1 Purpose</h3>
<p>Return a <strong>topological feature vector <code>F</code> fast</strong>, under strict timeouts, robust to IBM API issues.</p>
<p>Minimum required output for MVP:
- <code>beta1_estimate</code> (float or int)
- <code>confidence</code> (0..1) or <code>source</code> (<code>quantum</code> | <code>cache</code> | <code>fallback</code>)</p>
<h3 id="72-io-contract">7.2 I/O Contract</h3>
<p>Input:
- <code>Q</code> (dense <code>N×N</code>)
Output:
- <code>F = { beta1_estimate, ... }</code></p>
<h3 id="73-algorithm-sketch-lgz-like-ranklaplacian-estimation">7.3 Algorithm Sketch (LGZ-like Rank/Laplacian Estimation)</h3>
<p>We estimate <code>β₁</code> via the kernel dimension of the combinatorial 1-Laplacian <code>L1</code>:
- Construct a simplicial representation from <code>Q</code> (MVP: use skeleton graph and optional 2-simplices by threshold).
- Build boundary operators and <code>L1</code>.
- Encode <code>L1</code> as a Hermitian operator / Hamiltonian.
- Use Qiskit Runtime primitives to estimate spectral weight near zero.</p>
<p>Heat-trace estimator (conceptual):</p>
<pre><code>beta1 ≈ Tr(exp(-τ L1))    for large τ
</code></pre>
<p><strong>MVP reality requirement:</strong>
- The runtime program must return within <code>T_quantum=3s</code> or we fall back.
- If quantum execution cannot meet this, run the same estimator on a smaller sampled subcomplex (document the sampling).</p>
<p>MVP fallback (must be implemented regardless):
- If quantum is unavailable, estimate a graph-level cycle count on the skeleton:
  - For a graph (1-complex), <code>beta1_graph = m - n + c</code> (edges - nodes + connected components).
  - Use this only as a degraded signal for choosing <code>k</code> and stabilizing <code>W</code>.</p>
<h3 id="74-timeouts-budgets-fail-safes">7.4 Timeouts, Budgets, Fail-Safes</h3>
<ul>
<li>Hard timeout: <code>T_quantum = 3.0s</code> (configurable).</li>
<li>Budget: <code>≤ Q_calls_per_hour</code> (initial 10/h).</li>
<li>Fail-safe: on timeout or non-2xx response:</li>
<li>Use cached <code>F_cache</code></li>
<li>Mark attempt as <code>degraded_quantum=true</code></li>
</ul>
<h3 id="75-cache-keys">7.5 Cache Keys</h3>
<p>Cache <code>F</code> by coarse buckets:
- <code>N_bucket = round(N / 250) * 250</code>
- <code>density_bucket = round(density_eps / 0.05) * 0.05</code>
- <code>weight_stats_bucket</code> (optional)</p>
<hr>
<h2 id="8-external-solver-optional-accelerator">8. External Solver (Optional Accelerator)</h2>
<p>MVP allows one of these:
- <strong>A)</strong> No external solver: use only Lift &amp; Repair (Section 6.4).
- <strong>B)</strong> External solver service (DA / cloud GPU) that accepts a QUBO and returns a candidate solution.</p>
<p>If using an external solver, define a stable interface:</p>
<h3 id="81-api-contract-example">8.1 API Contract (example)</h3>
<p>Request:</p>
<pre><code class="language-json">{
  &quot;job_id&quot;: &quot;string&quot;,
  &quot;domain&quot;: &quot;spin|binary&quot;,
  &quot;Q&quot;: &quot;packed matrix or URL&quot;,
  &quot;time_limit_s&quot;: 20.0,
  &quot;warm_start&quot;: &quot;optional seed solution&quot;
}
</code></pre>
<p>Response:</p>
<pre><code class="language-json">{
  &quot;solution&quot;: [0,1,0,...],
  &quot;energy&quot;: -123.45,
  &quot;solver_time_s&quot;: 18.7,
  &quot;status&quot;: &quot;ok|timeout|error&quot;
}
</code></pre>
<h3 id="82-failure-policy">8.2 Failure Policy</h3>
<ul>
<li>If external solver fails/slow: immediately continue with local Lift &amp; Repair using <code>s_seed</code>.</li>
</ul>
<hr>
<h2 id="9-testing-validation-mvp-minimal">9. Testing &amp; Validation (MVP, Minimal)</h2>
<h3 id="91-golden-dataset-local">9.1 Golden Dataset (local)</h3>
<p>Save ~20 real tasks from testnet to <code>tests/data/</code> as JSON (synapse snapshots).</p>
<p>Required local command:
- <code>run_pipeline --input tests/data/golden_01.json --deadline 45s</code></p>
<p>Acceptance (local):
- Produces a correctly shaped solution.
- Computes energy without NaN/overflow.
- Runs under the deadline budget.</p>
<h3 id="92-testnet-run-the-real-proof">9.2 Testnet Run (the real proof)</h3>
<p>Run miner on SN4 testnet for <code>≥ 2h</code> (then <code>24h</code>).
Log and track:
- latency per stage
- final energy
- accepted vs rejected submissions
- score/incentive if available</p>
<hr>
<h2 id="10-implementation-roadmap-feb-2026">10. Implementation Roadmap (Feb 2026)</h2>
<h3 id="week-1-skeleton">Week 1 — Skeleton</h3>
<ul>
<li>Implement Ingest + Submit to testnet.</li>
<li>Implement logging.</li>
<li>Dummy solver produces valid-shaped random solutions (for protocol verification).</li>
</ul>
<h3 id="week-2-brain-quantum-e8-core">Week 2 — Brain (Quantum + E8 core)</h3>
<ul>
<li>Implement E8 roots generator + snapping.</li>
<li>Implement W builder (skeleton graph + spectral embedding).</li>
<li>Implement Quantum Scout call + strict timeout + cache.</li>
</ul>
<h3 id="week-3-lift-repair">Week 3 — Lift &amp; Repair</h3>
<ul>
<li>Implement W⁺ + lifting + binarize/spinize.</li>
<li>Implement greedy repair with <code>O(N)</code> flip deltas.</li>
<li>Golden dataset pipeline.</li>
</ul>
<h3 id="week-4-tuning-proving">Week 4 — Tuning &amp; Proving</h3>
<ul>
<li>Tune time budgets, beam width <code>B</code>, skeleton <code>k</code>, thresholds.</li>
<li>24h testnet run and KPI evaluation.</li>
</ul>
<hr>
<h2 id="11-risks-mitigations-mvp">11. Risks &amp; Mitigations (MVP)</h2>
<p>1) <strong>IBM latency / quota</strong> → strict timeout + cached features + degraded mode.
2) <strong>SN4 protocol changes</strong> → isolate synapse parsing and submission behind interfaces.
3) <strong>Dense matrix performance</strong> → enforce float32 + BLAS + memory budget checks.
4) <strong>Projection error (W bad)</strong> → beam width &gt;1 + repair randomized restarts.
5) <strong>Correlation gap (E8 reduced energy ≠ real energy)</strong> → evaluate top-B roots + pick best after repair.</p>
<hr>
<h2 id="12-reference-implementation-outline-minimal-ai-friendly">12. Reference Implementation Outline (Minimal, AI-Friendly)</h2>
<p>Recommended Python module boundaries (names are suggestions; keep interfaces stable):
- <code>miner/ingest.py</code>: synapse parsing → <code>(Q, meta)</code>
- <code>miner/quantum_scout.py</code>: <code>Q</code> → <code>F</code> with timeout + cache + fallback
- <code>miner/w_builder.py</code>: <code>(Q, F)</code> → <code>W, W_plus</code>
- <code>miner/e8.py</code>: root generator + snapping + reduced energy ranking
- <code>miner/lift_repair.py</code>: lift, binarize/spinize, greedy repair, energy
- <code>miner/submit.py</code>: submit to subnet
- <code>miner/main.py</code>: sniper loop + budgets + logging</p>
<p>Minimal CLI commands for MVP:
- <code>miner run --subnet 4 --network testnet --wallet &lt;name&gt;</code>
- <code>miner replay --input tests/data/golden_01.json --deadline 45s</code></p>
<hr>
<h2 id="13-configuration-mvp">13. Configuration (MVP)</h2>
<h3 id="131-environment-variables">13.1 Environment Variables</h3>
<ul>
<li><code>IBM_TOKEN</code> (if using Qiskit Runtime)</li>
<li><code>SOLVER_API_KEY</code> / <code>SOLVER_URL</code> (if using an external solver)</li>
<li><code>BT_WALLET_NAME</code> / <code>BT_WALLET_HOTKEY</code> (per Bittensor conventions; confirm)</li>
</ul>
<h3 id="132-runtime-parameters-config-file-or-cli">13.2 Runtime Parameters (config file or CLI)</h3>
<ul>
<li>Timeouts: <code>T_ingest</code>, <code>T_quantum</code>, <code>T_W</code>, <code>T_repair</code>, <code>T_submit</code></li>
<li>Beam width: <code>B</code></li>
<li>Skeletonization: <code>k_min</code>, <code>k_max</code>, <code>eps_density</code></li>
<li>Determinism: <code>RNG_SEED</code> (for repair restarts; default fixed)</li>
</ul>
<hr>
<h2 id="appendix-a-deterministic-generator-for-240-e8-roots">Appendix A — Deterministic Generator for 240 E8 Roots</h2>
<p><strong>Type A (112 roots):</strong>
- Choose 2 positions out of 8 for non-zero entries.
- Assign each of the two entries a sign <code>±1</code>.
- All permutations of positions and sign choices.</p>
<p><strong>Type B (128 roots):</strong>
- All 8-tuples of <code>±1/2</code> with an even number of negative signs.</p>
<p>Implementation note:
- Return a stable ordering (lexicographic) for reproducibility.</p>
<hr>
<h2 id="appendix-b-greedy-repair-fast-e-updates-spin-form">Appendix B — Greedy Repair: Fast ΔE Updates (Spin Form)</h2>
<p>For spins <code>s ∈ {-1,+1}^N</code>, energy:</p>
<pre><code>H = sᵀ Q s
</code></pre>
<p>Maintain <code>g = Q s</code> (vector length <code>N</code>).</p>
<p>Flipping spin <code>i</code> (<code>s_i := -s_i</code>) changes energy by:</p>
<pre><code>ΔH_i = -4 * s_i * g_i + 4 * Q_ii
</code></pre>
<p>(Derive/confirm based on the exact diagonal convention used by SN4 tasks; adjust once the dataset is verified.)</p>
<p>After flipping <code>i</code>, update:</p>
<pre><code>g := g + (-2*s_i_old) * Q[:, i]
</code></pre>
<p>This makes each flip <code>O(N)</code>.</p>
<hr>
<h2 id="appendix-c-minimal-structured-log-schema-jsonl">Appendix C — Minimal Structured Log Schema (JSONL)</h2>
<p>One line per task attempt:</p>
<pre><code class="language-json">{
  &quot;ts&quot;: &quot;iso8601&quot;,
  &quot;job_id&quot;: &quot;string&quot;,
  &quot;N&quot;: 5000,
  &quot;density_eps&quot;: 0.92,
  &quot;degraded_quantum&quot;: false,
  &quot;beta1&quot;: 37.0,
  &quot;beam_B&quot;: 8,
  &quot;energy&quot;: -123.45,
  &quot;latency_total_s&quot;: 31.2,
  &quot;latency&quot;: { &quot;ingest&quot;: 0.2, &quot;quantum&quot;: 2.9, &quot;W&quot;: 3.8, &quot;repair&quot;: 23.1, &quot;submit&quot;: 1.0 },
  &quot;submit_status&quot;: &quot;ok|rejected|timeout|error&quot;
}
</code></pre>
<hr>
<h2 id="appendix-d-must-check-items-do-before-coding">Appendix D — MUST-CHECK Items (Do Before Coding)</h2>
<ul>
<li>Confirm SN4 synapse schema and actual submission API in the current subnet repository.</li>
<li>Confirm variable domain and diagonal conventions in energy computation.</li>
<li>Confirm whether the validator expects energy or only a solution vector.</li>
<li>Confirm IBM/Qiskit runtime latency and select an executable strategy that fits <code>T_quantum</code>.</li>
</ul>
</body>
</html>
